#+TITLE: How to write a fast grep command

* Why do we need a fast grep like command?
  + We need to analyze a huge amount of log data per day i.e more than 500GBytes and we only keep our log files for 7 days.
  + We want to actively monitor our large distributed system using both weblog and graphite monitoring system. For example we want to get
	+ Automatically identify new issues
	+ Get a daily/hourly report about the health of our system from weblog. This is a complement to our grafana dashboards.
	+ Check life cycle of messages, jobs, or tasks.

* Requirements
  + Efficient file I/O
  + Optimized parsers.
  + Fast console I/O.

* Test environments

** Development servers
   + CPU: Intel(R) Xeon(R) CPU E5-2699 v4 @ 2.20GHz
   + Memory: 773519 MBytes
   + Storage: Very fast network storage.

** Macbook Pro
   + CPU: Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz
   + Memory: 16 GB
   + Storage: SSD

* [[https://lemire.me/blog/2012/06/26/which-is-fastest-read-fread-ifstream-or-mmap/][How to write a fast file reader]]?

There are many way to read the file content into a buffer in C++. Below are three typical solutions that can work with large files:
1. File stream: This is the most common solution, however, it is known that this solution is not efficient enough for serious tasks. 
2. The memory mapped solution: This solution can provide a good enough solution for most file I/O tasks while hiding all low level information from users.
3. Using low level file I/O APIs: It has been reported that this approach is the best (https://lemire.me/blog/2012/06/26/which-is-fastest-read-fread-ifstream-or-mmap/) and it has been used in GNU wc/grep commands.

Below are implementations for three algorithms above:

#+BEGIN_SRC
    template <typename Container> Container read_iostream(const std::string &afile) {
        std::ifstream t(afile);
        Container str;

        // Note: This is pretty bad.
        t.seekg(0, std::ios::end);
        str.reserve(t.tellg());
        t.seekg(0, std::ios::beg);

        str.assign((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());
        return str;
    }
#+END_SRC

#+BEGIN_SRC
    template <typename Container> Container read_memmap(const std::string &afile) {
        boost::iostreams::mapped_file mmap(afile, boost::iostreams::mapped_file::readonly);
        auto begin = mmap.const_data();
        auto end = begin + mmap.size();
        return Container(begin, end);
    }
#+END_SRC

#+BEGIN_SRC
    template <typename Container>
    void read(const char *afile, Container &buffer, char *buf, const size_t buffer_size) {
        int fd = ::open(afile, O_RDONLY);

        // Check that we can open a given file.
        if (fd < 0) {
            fmt::MemoryWriter writer;
            writer << "Cannot open file \"" << afile << "\"";
            throw(std::runtime_error(writer.str()));
        }

        // Reserve the size of a buffer using file size information.
        struct stat file_stat;
        if (fstat(fd, &file_stat) < 0) return;
        buffer.reserve(file_stat.st_size);

        // Read data.
        while (true) {
            auto nbytes = ::read(fd, buf, buffer_size);
            if (nbytes < 0) {
                fmt::MemoryWriter writer;
                writer << "Cannot read file \"" << afile << "\"";
                throw(std::runtime_error(writer.str()));
            };

            buffer.append(buf, nbytes);

            // Stop if we reach the end of file.
            if (nbytes != static_cast<decltype(nbytes)>(buffer_size)) {
                break;
            };
        }

        // Close our file.
        ::close(fd);
    }
#+END_SRC

** Benchmark results

We use [[https://github.com/DigitalInBlue/Celero][Celero]] to benchmark our file I/O algorithms in both Linux and Mac OS environments and our tested file size is 300KBytes. From the benchmark results we can easily jump to below conclusions:
1. The ifstream solution is the worst solution i.e it is 20x slower than that of memory mapped solution. We should not use it for serious tasks.
2. Memory mapped solution has decent performance and we should use it by default.
3. Low level file I/O is the best, however, it is not portable i.e does not work in Windows.

*** Linux i.e our development servers

#+BEGIN_SRC
[prod PTEST1] hdang@dev115:~/working/ioutils/benchmark> ./read_data
Celero
Timer resolution: 0.001000 us
-----------------------------------------------------------------------------------------------------------------------------------------------
     Group      |   Experiment    |   Prob. Space   |     Samples     |   Iterations    |    Baseline     |  us/Iteration   | Iterations/sec  |
-----------------------------------------------------------------------------------------------------------------------------------------------
read            | iostream        |               0 |              10 |               1 |         1.00000 |      9512.00000 |          105.13 |
read            | boost_memmap    |               0 |              10 |               1 |         0.04762 |       453.00000 |         2207.51 |
read            | read_2_10       |               0 |              10 |               1 |         0.10219 |       972.00000 |         1028.81 |
read            | read_2_12       |               0 |              10 |               1 |         0.04310 |       410.00000 |         2439.02 |
read            | read_2_13       |               0 |              10 |               1 |         0.03553 |       338.00000 |         2958.58 |
read            | read_2_14       |               0 |              10 |               1 |         0.03133 |       298.00000 |         3355.70 |
read            | read_2_15       |               0 |              10 |               1 |         0.02986 |       284.00000 |         3521.13 |
read            | read_2_16       |               0 |              10 |               1 |         0.02881 |       274.00000 |         3649.64 |
read            | read_2_17       |               0 |              10 |               1 |         0.02796 |       266.00000 |         3759.40 |
read            | read_2_18       |               0 |              10 |               1 |         0.02849 |       271.00000 |         3690.04 |
read            | read_2_19       |               0 |              10 |               1 |         0.03017 |       287.00000 |         3484.32 |
read            | read_2_20       |               0 |              10 |               1 |         0.02849 |       271.00000 |         3690.04 |
Complete.
#+END_SRC

*** MacOS

#+BEGIN_SRC
hdang@015249 ~/w/i/benchmark> ./read_data
Celero
Timer resolution: 0.001000 us
-----------------------------------------------------------------------------------------------------------------------------------------------
     Group      |   Experiment    |   Prob. Space   |     Samples     |   Iterations    |    Baseline     |  us/Iteration   | Iterations/sec  |
-----------------------------------------------------------------------------------------------------------------------------------------------
read            | iostream        |               0 |              10 |               1 |         1.00000 |      1854.00000 |          539.37 |
read            | boost_memmap    |               0 |              10 |               1 |         0.07605 |       141.00000 |         7092.20 |
read            | read_2_10       |               0 |              10 |               1 |         0.21143 |       392.00000 |         2551.02 |
read            | read_2_12       |               0 |              10 |               1 |         0.07335 |       136.00000 |         7352.94 |
read            | read_2_13       |               0 |              10 |               1 |         0.05448 |       101.00000 |         9900.99 |
read            | read_2_14       |               0 |              10 |               1 |         0.04315 |        80.00000 |        12500.00 |
read            | read_2_15       |               0 |              10 |               1 |         0.03398 |        63.00000 |        15873.02 |
read            | read_2_16       |               0 |              10 |               1 |         0.03290 |        61.00000 |        16393.44 |
read            | read_2_17       |               0 |              10 |               1 |         0.03074 |        57.00000 |        17543.86 |
read            | read_2_18       |               0 |              10 |               1 |         0.03182 |        59.00000 |        16949.15 |
read            | read_2_19       |               0 |              10 |               1 |         0.03182 |        59.00000 |        16949.15 |
read            | read_2_20       |               0 |              10 |               1 |         0.03452 |        64.00000 |        15625.00 |
Complete.
#+END_SRC

* How to write an efficient command that displays the summary information of files i.e file size, the number of lines, and max line length.
Now, we know that our solution for reading a file content is the fastest let write a simple command that can display the line information of a text file to see if our solution works in real life.
The command that we will implement has below specifications:
1. Can report the file size.
2. Can report the number of lines.
3. Can report the maximum and minimum line lengths.

#+BEGIN_SRC
    // A struct that read file content in fixed size chunks and parse them to a parser.
    template <size_t BUFFER_SIZE, typename Parser> class FileReader {
      public:
        void operator()(const char *datafile, Parser &parser, const size_t offset = 0) {
            char read_buffer[BUFFER_SIZE + 1];
            int fd = ::open(datafile, O_RDONLY);

            // Check that we can open a given file.
            if (fd < 0) {
                std::stringstream writer;
                writer << "Cannot open file \"" << datafile << "\"";
                throw(std::runtime_error(writer.str()));
            }

            // Shift to desired location if it is not zero.
            if (offset) {
                auto retval = lseek(fd, offset, SEEK_SET);
                if (retval != offset) {
                    std::stringstream writer;
                    writer << "Cannot seek for the location " << offset << " in " << datafile;
                    throw(std::runtime_error(writer.str()));
                }
            }

            // Read data into a string
            while (true) {
                auto nbytes = ::read(fd, read_buffer, BUFFER_SIZE);
                if (nbytes < 0) {
                    std::stringstream writer;
                    writer << "Cannot read file \"" << datafile << "\"";
                    throw(std::runtime_error(writer.str()));
                };

                // Parse read_buffer to get some useful information.
                parser(read_buffer, read_buffer + nbytes);

                // Stop if we reach the end of file.
                if (nbytes != static_cast<decltype(nbytes)>(BUFFER_SIZE)) { break; };
            }

            // Close our file.
            ::close(fd);
        }
    };
#+END_SRC

** How fast is our command?
*** Get the line information using wc command
#+BEGIN_SRC
[prod PTEST1] hdang@dev115:~/working/scribe_parser/commands> /usr/bin/time --verbose wc -l /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000
7908977 /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000
        Command being timed: "wc -l /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000"
        User time (seconds): 2.76 <====
        System time (seconds): 1.60 <====
        Percent of CPU this job got: 99%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 0:04.37 <====
        Average shared text size (kbytes): 0
        Average unshared data size (kbytes): 0
        Average stack size (kbytes): 0
        Average total size (kbytes): 0
        Maximum resident set size (kbytes): 632
        Average resident set size (kbytes): 0
        Major (requiring I/O) page faults: 0
        Minor (reclaiming a frame) page faults: 192
        Voluntary context switches: 1
        Involuntary context switches: 10
        Swaps: 0
        File system inputs: 0
        File system outputs: 0
        Socket messages sent: 0
        Socket messages received: 0
        Signals delivered: 0
        Page size (bytes): 4096
        Exit status: 0
#+END_SRC

*** Get line information using our command i.e linestats
#+BEGIN_SRC
[prod PTEST1] hdang@dev115:~/working/scribe_parser/commands> /usr/bin/time --verbose ./linestats /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000
Number of bytes: 5520716853
Number of lines: 7908977
Max line length: 655995
Min line lenght: 131
File size: 5520716853
        Command being timed: "./linestats /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000"
        User time (seconds): 1.18 <====
        System time (seconds): 1.29 <====
        Percent of CPU this job got: 99%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 0:02.48 <====
        Average shared text size (kbytes): 0
        Average unshared data size (kbytes): 0
        Average stack size (kbytes): 0
        Average total size (kbytes): 0
        Maximum resident set size (kbytes): 1724
        Average resident set size (kbytes): 0
        Major (requiring I/O) page faults: 0
        Minor (reclaiming a frame) page faults: 459
        Voluntary context switches: 9
        Involuntary context switches: 15
        Swaps: 0
        File system inputs: 0
        File system outputs: 0
        Socket messages sent: 0
        Socket messages received: 0
        Signals delivered: 0
        Page size (bytes): 4096
        Exit status: 0
#+END_SRC

*** Why linestats is faster that wc eventhough we do more?

#+BEGIN_SRC

 Performance counter stats for './linestats /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000' (5 runs):

       2486.441365 task-clock                #    0.998 CPUs utilized            ( +-  0.47% )
                25 context-switches          #    0.010 K/sec                    ( +- 10.65% )
                 2 cpu-migrations            #    0.001 K/sec                    ( +- 31.18% )
               445 page-faults               #    0.179 K/sec                    ( +-  0.09% )
     5,475,324,084 cycles                    #    2.202 GHz                      ( +-  0.47% )
   <not supported> stalled-cycles-frontend
   <not supported> stalled-cycles-backend
     2,679,405,089 instructions              #    0.49  insns per cycle          ( +-  0.01% )
       426,067,527 branches                  #  171.356 M/sec                    ( +-  0.02% )
        58,853,387 branch-misses             #   13.81% of all branches          ( +-  0.05% )

       2.492355048 seconds time elapsed                                          ( +-  0.48% )

 Performance counter stats for 'wc -l /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000' (5 runs):

       4313.595973 task-clock                #    0.999 CPUs utilized            ( +-  0.56% )
                13 context-switches          #    0.003 K/sec                    ( +- 21.48% )
                 2 cpu-migrations            #    0.001 K/sec                    ( +- 77.94% )
               170 page-faults               #    0.039 K/sec
     9,499,009,163 cycles                    #    2.202 GHz                      ( +-  0.56% )
   <not supported> stalled-cycles-frontend
   <not supported> stalled-cycles-backend
     3,906,703,903 instructions              #    0.41  insns per cycle          ( +-  0.04% )
       907,193,896 branches                  #  210.310 M/sec                    ( +-  0.03% )
        21,247,916 branch-misses             #    2.34% of all branches          ( +-  0.16% )

       4.318761916 seconds time elapsed                                          ( +-  0.56% )

#+END_SRC

*** Lesson learned
	+ Compile time optimization play an important role here since linestats and wc are very similar.
	+ Fine tuning for specific systems pay off.
	+ C++ will outperform C if we know what we are doing.

* How to write a fast "simple" grep command?

** Initial solution using std::string::find
#+BEGIN_SRC
    class SimpleConstraints {
      public:
        using Contains = utils::baseline::Contains;
        SimpleConstraints(const MessageFilterParams &params) : contains(params.pattern) {}
        bool operator()(const std::string &line) { return contains(line); }

      private:
        Contains contains; // Search for a given string pattern
    };
#+END_SRC

** Benchmark results

Below are the comparison results of our customized grep and the most popular grep like command for "Starting123" pattern

| Command        | sys  | user | real |
|----------------+------+------+------|
| [[https://www.gnu.org/software/grep/][grep]]           | 0.04 | 0.06 | 0.11 |
| [[https://github.com/BurntSushi/ripgrep][ripgrep]]        | 0.05 | 0.07 | 0.13 |
| [[https://github.com/ggreer/the_silver_searcher][ag]]             | 0.17 | 0.03 | 0.22 |
| [[https://github.com/hungptit/scribe_parser/blob/working/commands/message_filter.cpp][message-filter]] | 0.04 | 0.06 | 0.11 |

Note: MacOS grep command is very slow, I used brew-grep in my benchmark.

*** Detail benchmark results in MacOS

**** message-filter
#+BEGIN_SRC
hdang@015249 ~/w/s/commands> time -lp ./message_filter -p Starting123 ../data/workqueue-execution_current
real         0.11
user         0.06
sys          0.04
   3313664  maximum resident set size
         0  average shared memory size
         0  average unshared data size
         0  average unshared stack size
       827  page reclaims
         0  page faults
         0  swaps
         0  block input operations
         0  block output operations
         0  messages sent
         0  messages received
         0  signals received
         2  voluntary context switches
       100  involuntary context switches
#+END_SRC

**** grep
#+BEGIN_SRC
real         0.10
user         0.06
sys          0.03
   3219456  maximum resident set size
         0  average shared memory size
         0  average unshared data size
         0  average unshared stack size
       802  page reclaims
         0  page faults
         0  swaps
         0  block input operations
         0  block output operations
         0  messages sent
         0  messages received
         0  signals received
         2  voluntary context switches
        30  involuntary context switches
#+END_SRC
**** ripgrep
#+BEGIN_SRC
hdang@015249 ~/w/s/commands> time -lp rg Starting123 ../data/workqueue-execution_current

#+END_SRC
**** ag
#+BEGIN_SRC
hdang@015249 ~/w/s/commands> time -lp ag Starting123 ../data/workqueue-execution_current
real         0.20
user         0.03
sys          0.15
 190373888  maximum resident set size
         0  average shared memory size
         0  average unshared data size
         0  average unshared stack size
     47946  page reclaims
         0  page faults
         0  swaps
         0  block input operations
         0  block output operations
         0  messages sent
         0  messages received
         0  signals received
         9  voluntary context switches
        57  involuntary context switches
#+END_SRC

** Detail benchmark results for very large files
#+BEGIN_SRC
[prod PTEST1] hdang@dev115:~/working/scribe_parser/commands> /usr/bin/time --verbose ./message_filter -p Starting123 /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000
        Command being timed: "./message_filter -p Starting123 /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000"
        User time (seconds): 42.43
        System time (seconds): 1.35
        Percent of CPU this job got: 99%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 0:43.83 <===
        Average shared text size (kbytes): 0
        Average unshared data size (kbytes): 0
        Average stack size (kbytes): 0
        Average total size (kbytes): 0
        Maximum resident set size (kbytes): 3904
        Average resident set size (kbytes): 0
        Major (requiring I/O) page faults: 0
        Minor (reclaiming a frame) page faults: 1007
        Voluntary context switches: 15
        Involuntary context switches: 78
        Swaps: 0
        File system inputs: 0
        File system outputs: 0
        Socket messages sent: 0
        Socket messages received: 0
        Signals delivered: 0
        Page size (bytes): 4096
        Exit status: 0

[prod PTEST1] hdang@dev115:~/working/scribe_parser/commands> /usr/bin/time --verbose grep Starting123 /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000
Command exited with non-zero status 1
        Command being timed: "grep Starting123 /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000"
        User time (seconds): 4.66
        System time (seconds): 1.16
        Percent of CPU this job got: 99%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 0:05.83 <===
        Average shared text size (kbytes): 0
        Average unshared data size (kbytes): 0
        Average stack size (kbytes): 0
        Average total size (kbytes): 0
        Maximum resident set size (kbytes): 1928
        Average resident set size (kbytes): 0
        Major (requiring I/O) page faults: 0
        Minor (reclaiming a frame) page faults: 743
        Voluntary context switches: 1
        Involuntary context switches: 10
        Swaps: 0
        File system inputs: 0
        File system outputs: 0
        Socket messages sent: 0
        Socket messages received: 0
        Signals delivered: 0
        Page size (bytes): 4096
        Exit status: 1
#+END_SRC

** Why message_filter is much slower than grep for large files?

*** The performance report using perf command
#+BEGIN_SRC
# ========
# captured on: Fri Mar 30 17:32:15 2018
# hostname : dev115.athenahealth.com
# os release : 3.8.13-118.20.2.el6uek.x86_64
# perf version : 3.8.13-118.20.2.el6uek.x86_64
# arch : x86_64
# nrcpus online : 88
# nrcpus avail : 88
# cpudesc : Intel(R) Xeon(R) CPU E5-2699 v4 @ 2.20GHz
# cpuid : GenuineIntel,6,79,1
# total memory : 792083644 kB
# cmdline : /usr/libexec/perf.3.8.13-118.20.2.el6uek.x86_64 record ./message_filter -p Starting123 /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000
# event : name = cycles, type = 0, config = 0x0, config1 = 0x0, config2 = 0x0, excl_usr = 0, excl_kern = 0, excl_host = 0, excl_guest = 1, precise_ip = 0, id = { 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559
# HEADER_CPU_TOPOLOGY info available, use -I to display
# HEADER_NUMA_TOPOLOGY info available, use -I to display
# pmu mappings: cpu = 4, software = 1, tracepoint = 2, breakpoint = 5
# ========
#
# Samples: 181K of event 'cycles'
# Event count (approx.): 97609612007
#
# Overhead         Command        Shared Object                                                                                                     Symbol
# ........  ..............  ...................  .........................................................................................................
#
    82.06%  message_filter  libstdc++.so.6.0.21  [.] _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4findEPKcmm
     9.15%  message_filter  libc-2.23.so         [.] __memcmp_sse4_1
     2.52%  message_filter  libc-2.23.so         [.] memchr
     2.24%  message_filter  [kernel.kallsyms]    [k] copy_user_enhanced_fast_string
     1.09%  message_filter  libc-2.23.so         [.] __memcpy_avx_unaligned
     0.44%  message_filter  message_filter       [.] _ZN6scribe10FileReaderILm131072ENS_13MessageFilterINS_17SimpleConstraintsEEEEclEPKcRS3_l.constprop.17
     0.36%  message_filter  libstdc++.so.6.0.21  [.] _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_appendEPKcm
     0.20%  message_filter  libstdc++.so.6.0.21  [.] memcmp@plt
     0.18%  message_filter  [kernel.kallsyms]    [k] ii_iovec_copy_to_user
     0.13%  message_filter  [kernel.kallsyms]    [k] find_get_page
     0.12%  message_filter  [kernel.kallsyms]    [k] do_generic_file_read.clone.0
     0.12%  message_filter  [kernel.kallsyms]    [k] radix_tree_lookup_slot
     0.06%  message_filter  [kernel.kallsyms]    [k] mark_page_accessed
     0.06%  message_filter  [kernel.kallsyms]    [k] ii_iovec_advance
     0.05%  message_filter  [kernel.kallsyms]    [k] native_write_msr_safe
     0.05%  message_filter  [kernel.kallsyms]    [k] apic_timer_interrupt
     0.04%  message_filter  [kernel.kallsyms]    [k] file_read_iter_actor
#+END_SRC

*** What is the bottle neck?
	+ Our command spent 82.06% time on std::string::find. We do need a faster string find algorithm.

** [[https://arxiv.org/abs/1612.01506][How to write a fast std::string::find algorithm]]
   + Need better algorithms.
   + Use SIMD instruction set.

** Benchmark results for std::string::find, SSE2 strstr, and AVX2 strstr algorithms
#+BEGIN_SRC
[prod PTEST1] hdang@dev115:~/working/utils/benchmark> ./string
2018-03-30 17:37:21
Running ./string
Run on (88 X 2199.81 MHz CPU s)
CPU Caches:
  L1 Data 32K (x44)
  L1 Instruction 32K (x44)
  L2 Unified 256K (x44)
  L3 Unified 56320K (x2)
--------------------------------------------------------
Benchmark                 Time           CPU Iterations
--------------------------------------------------------
std_string_find        1152 ns       1151 ns     607947
sse2_string_find        170 ns        170 ns    4120322
avx2_string_find        113 ns        113 ns    6213548
[prod PTEST1] hdang@dev115:~/working/utils/benchmark>
#+END_SRC

** Benchmark results for message_filter command

*** SSE2 version of message_filter
#+BEGIN_SRC
[prod PTEST1] hdang@dev115:~/working/scribe_parser/commands> /usr/bin/time --verbose ./message_filter -p Starting123 /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000
        Command being timed: "./message_filter -p Starting123 /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000"
        User time (seconds): 7.33
        System time (seconds): 1.24
        Percent of CPU this job got: 99%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 0:08.59 <===
        Average shared text size (kbytes): 0
        Average unshared data size (kbytes): 0
        Average stack size (kbytes): 0
        Average total size (kbytes): 0
        Maximum resident set size (kbytes): 2800
        Average resident set size (kbytes): 0
        Major (requiring I/O) page faults: 0
        Minor (reclaiming a frame) page faults: 905
        Voluntary context switches: 16
        Involuntary context switches: 15
        Swaps: 0
        File system inputs: 0
        File system outputs: 0
        Socket messages sent: 0
        Socket messages received: 0
        Signals delivered: 0
        Page size (bytes): 4096
        Exit status: 0
#+END_SRC

*** AVX2 version of message_filter
#+BEGIN_SRC
[prod PTEST1] hdang@dev115:~/working/scribe_parser/commands> /usr/bin/time --verbose ./message_filter -p Starting123 /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000
        Command being timed: "./message_filter -p Starting123 /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000"
        User time (seconds): 4.52
        System time (seconds): 1.31
        Percent of CPU this job got: 99%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 0:05.87 <===
        Average shared text size (kbytes): 0
        Average unshared data size (kbytes): 0
        Average stack size (kbytes): 0
        Average total size (kbytes): 0
        Maximum resident set size (kbytes): 2800
        Average resident set size (kbytes): 0
        Major (requiring I/O) page faults: 0
        Minor (reclaiming a frame) page faults: 906
        Voluntary context switches: 23
        Involuntary context switches: 10
        Swaps: 0
        File system inputs: 0
        File system outputs: 0
        Socket messages sent: 0
        Socket messages received: 0
        Signals delivered: 0
        Page size (bytes): 4096
        Exit status: 0
#+END_SRC

*** Performance profiling for AVX2 message_filter
#+BEGIN_SRC
# ========
# captured on: Fri Mar 30 19:54:05 2018
# hostname : dev115.athenahealth.com
# os release : 3.8.13-118.20.2.el6uek.x86_64
# perf version : 3.8.13-118.20.2.el6uek.x86_64
# arch : x86_64
# nrcpus online : 88
# nrcpus avail : 88
# cpudesc : Intel(R) Xeon(R) CPU E5-2699 v4 @ 2.20GHz
# cpuid : GenuineIntel,6,79,1
# total memory : 792083644 kB
# cmdline : /usr/libexec/perf.3.8.13-118.20.2.el6uek.x86_64 record ./message_filter -p Starting123 /mnt/weblogs/scribe/workqueue-execution/workqueue-execution-2018-03-30_00000
# event : name = cycles, type = 0, config = 0x0, config1 = 0x0, config2 = 0x0, excl_usr = 0, excl_kern = 0, excl_host = 0, excl_guest = 1, precise_ip = 0, id = { 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735
# HEADER_CPU_TOPOLOGY info available, use -I to display
# HEADER_NUMA_TOPOLOGY info available, use -I to display
# pmu mappings: cpu = 4, software = 1, tracepoint = 2, breakpoint = 5
# ========
#
# Samples: 24K of event 'cycles'
# Event count (approx.): 13166355714
#
# Overhead         Command        Shared Object                                                                                                                               Symbol
# ........  ..............  ...................  ...................................................................................................................................
#
    42.05%  message_filter  message_filter       [.] _ZN5utils4avx214avx2_strstr_v2EPKcmS2_m.part.46.lto_priv.84
    18.38%  message_filter  libc-2.23.so         [.] memchr
    16.01%  message_filter  [kernel.kallsyms]    [k] copy_user_enhanced_fast_string
     8.23%  message_filter  libc-2.23.so         [.] __memcpy_avx_unaligned
     3.47%  message_filter  message_filter       [.] _ZN6scribe10FileReaderILm131072ENS_13MessageFilterINS_17SimpleConstraintsEEEEclEPKcRS3_l.constprop.17
     2.56%  message_filter  libstdc++.so.6.0.21  [.] _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_appendEPKcm
     1.43%  message_filter  [kernel.kallsyms]    [k] ii_iovec_copy_to_user
     0.97%  message_filter  [kernel.kallsyms]    [k] find_get_page
     0.89%  message_filter  [kernel.kallsyms]    [k] radix_tree_lookup_slot
     0.80%  message_filter  [kernel.kallsyms]    [k] do_generic_file_read.clone.0
     0.56%  message_filter  [kernel.kallsyms]    [k] mark_page_accessed
     0.46%  message_filter  [kernel.kallsyms]    [k] ii_iovec_advance
     0.35%  message_filter  [kernel.kallsyms]    [k] file_read_iter_actor
     0.34%  message_filter  message_filter       [.] memchr@plt
     0.30%  message_filter  [kernel.kallsyms]    [k] put_page
     0.29%  message_filter  [kernel.kallsyms]    [k] _cond_resched
     0.23%  message_filter  message_filter       [.] _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_appendEPKcm@plt
     0.19%  message_filter  [kernel.kallsyms]    [k] sysret_check
     0.16%  message_filter  libstdc++.so.6.0.21  [.] memcpy@plt
#+END_SRC

* Demo
** Filter log messages using string pattern
** Filter message using timestamp.

* Summary
** We have demonstrate that we can create a fast "simple" grep command that can run as fast as the best grep like commands.
** Profiling and benchmarking tools are your friends when troubleshooting performance issues.
** C++ is still the king if we know what we do.

* Plan
** A tool that can
   + Automatically identify new issues.
   + Create daily/hourly reports for web log data.
   + Actively monitoring our system in near realtime.
** Provide a backend service that
   + Allow users to search for log messages fast.
   + Better aglimse command.
** Support regular expression.
